---
title: "Untitled"
output: html_document
date: "2024-12-03"
---

# Module 13

## select() - selecting variables (columns)

```{r}
library(nycflights13)
library(tidyverse)
names(flights)
#you can subset variables like this
select(flights,year,month,day)

#you can selected ranges of variables (columns) without using the column number 
select(flights,year:day)


#and just do this for the compliment
select(flights,!(year:day))


```

selection functions for subsetting exactly what you want

```{r}

#starts_with(): Starts with a prefix.

#ends_with(): Ends with a suffix.

#contains(): Contains a literal string.

#matches(): Matches a regular expression.

#num_range(): Matches a numerical range like x01, x02, x03.

```

examples of how to use these selection functions

```{r}
select(flights, starts_with("dep"))

select(flights, ends_with("time"))

select(flights, contains("time"))

# this is or 
select(flights, starts_with("dep"), contains("time"), year:day)

# this is just the column numbers 
select(flights, c(1,3,5))

#select columns that are numbered but also have a prefix 
select(billboard, num_range("wk", 20:23))


```

## filter() - selecting observations of variables (rows)

```{r}
# use
# & and 
# | or 
# ! not 
```

```{r}
#filter flights departed on january 1st 
#all rows (observations) that satisfy the criteria
filter(flights, month == 1 & day == 1)

#flights that depart on November or December 
filter(flights, month == 11 | month == 12)

# all flights where the destination is IAH 
filter(flights, dest == "IAH")

# all flights with arrival delay less than or equal to 2 hours 
# or departure delay greater than 2 hours 

#only one condition needs to be satisfied to be included
filter(flights, arr_delay <= 120 | dep_delay > 120)
```

## mutate() - apply a transformation to a variable or make new one 

```{r}
# from left to right future variables can use previous ones within the same statement 
mutate(flights, gain = arr_delay - dep_delay, hours = air_time/60, gain_per_hour = gain/hours)

```

### transmute()

```{r}
# same thing as filter but all variables other than the new ones just created will be removed
transmute(flights, gain = arr_delay - dep_delay, hours = air_time/60, gain_per_hour = gain/hours)

```

### variants of mutate() and transmute()

```{r}
#mutate_all() and transmute_all() affect every variable

#mutate_at() and transmute_at() affect variables selected with a character vector

#mutate_if() and transmute_if() affect variables selected with a predicate function (a function that returns TRUE or FALSE)
```

```{r}
head(iris,5)
#take the log() of all columns that include "Sepal" in their name and then assaign that to new tibble
mutated <- mutate_at(iris, vars(contains("Sepal")), log)

#you can specify to apply the function only to columns of specified data type 
mutated <- mutate_if(iris, is.numeric, log)
head(mutated)

#transmute would do the exact same thing just removal all other columns other than the ones that were transformed


#across() will apply a function to multiple different selection criteria 

```

## arrange() - reorder rows

```{r}
#reorder rows by numeric aescending value by default 
arrange(flights, year, month, day)

#or descending order
arrange(flights, desc(month))
```

## summarize() and group_by()

```{r}
#this will output a tibble with delay_mean which is the mean of the variable 
# dep_delay aswell output in the tibble delay_sd the standard dev of dep_delay
flights 

summarize(flights, delay_mean = mean(dep_delay, na.rm = TRUE), delay_sd = sd(dep_delay, na.rm = TRUE))
```

group_by() and summarize() together

```{r}
# will produce a group for each unique combination of the variables
by_day <- group_by(flights, year, month, day)

# takes that tibble of groups and evaluates the mean of variable dep_delay within each group 
summarize(by_day, delay = mean(dep_delay, na.rm = TRUE))

```

summarize functions

```{r}
# mean(), median(), sum(), min(), max(), sd(), var(), ... 
```

## pipe-line operator %\>%

```{r}
flights %>% 
  group_by(dest) %>% 
    summarize(count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE)) %>%
      filter(count > 20, dest != "HNL") %>% 
        ggplot(mapping = aes(x = dist, y = delay)) + 
          geom_point(aes(size = count), alpha = 1/3) + 
            geom_smooth(se = FALSE)
```

## more pipe-lines %\>%

```{r}
iris #remember you need to declare it as a tibble 
as_tibble(iris)

iris_grouped <- group_by(iris, Species) 
summarise_all(iris_grouped, mean)

#or you can just 

iris %>%
  group_by(Species) %>%
    summarise_all(mean)
    
#will output a summary of the observation groups where the summary is the mean of all columns within each group that start with Sepal in the variable name 
iris %>% 
  group_by(Species) %>%
    summarise(across(starts_with("Sepal"), mean))

# if you want the output from this for input to the next function in the pipeline to not be subject to previous grouping constraints for whatever reason. 
iris %>%
  group_by(Species) %>%
    summarise(across(starts_with("Sepal"), mean), .groups = "drop")


```

```{r}
library(candisc)
data(HSB)

# convert data frame to tibble 
HSB <- as_tibble(HSB)
HSB

# summary of data types 
str(HSB)

# the function n() will give you the number of observations of each of the groups passed from the previous function in the pipe-line
HSB %>%
  group_by(race) %>%
    summarise(n=n())

# count() will tell you how many observations there are of each of the possible unique values within the variable
HSB %>% 
  count(race)

# how many observations of each unique combination of variable values 
HSB %>%
  count(race, gender)

```

example of filtering and then summarizing

```{r}
#means of all of these variables for all students
HSB %>% 
  summarise(readm = mean(read), writem = mean(write), mathm = mean(math), ssm = mean(ss))

# for each gender 
HSB %>% 
  group_by(gender) %>%
    summarise(readm = mean(read), writem = mean(write), mathm = mean(math), ssm = mean(ss))

# for each gender and race 
HSB %>% 
  group_by(gender,race) %>%
    summarise(readm = mean(read), writem = mean(write), mathm = mean(math), ssm = mean(ss))

# for each gender evaluate the mean of all numeric variables
HSB %>% 
  group_by(gender) %>%
    summarise(across(where(is.numeric), mean, na.rm = TRUE))


# the means of all numeric variables by ses for only asian and hispanic
HSB %>%
  filter(race == "hispanic" | race == "asian") %>%
    group_by(ses) %>%
      summarise(across(where(is.numeric), mean, na.rm = TRUE))

```

```{r}
library(dplyr)
data(starwars)
glimpse(starwars) # similar to str() in Base R

#a. How many humans are contained in starwars overall? (Hint. use count())
starwars %>%
  filter(species == "Human") %>%
    summarise(observations = n())

#b. How many feminine humans are contained in starwars?
starwars %>%
  filter(species == "Human" & gender == "feminine") %>%
    summarise(observations = n())


#c. From which homeworld do the most individuals come from?
starwars %>%
  group_by(homeworld) %>%
    summarise(observations = n()) %>%
      filter(observations == max(observations))

  
#d. What is the mean height of all individuals with orange eyes from the most popular homeworld?
starwars %>%
  filter(eye_color == "orange" & homeworld == "Naboo") %>%
    summarise(mean_height = mean(height))

```

## tibble joins

```{r}
library(tidyverse)
# tribble() creates a tibble
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)

y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

```{r}

  #  inner_join() keeps observations that appear in both data frames
  #  left_join() keeps all observations in x
  #  right_join() keeps all observations in y
  #  full_join() keeps all observations in x and y

```

inner join - retains all variables which correspond to matching keys of both sets

```{r}
inner_join_1<- x %>% 
  inner_join(y, by = "key")

inner_join_1

#equivalently 
inner_join_2 <- inner_join(x, y, by = "key")
```

left join - retains all variables which correspond to the keys of x

```{r}
left_join <- x %>% 
  left_join(y, by = "key")
left_join

#equivalently 
left_join(x, y, by = "key")
```

right join - retains all variables which correspond to the keys of y

```{r}
right_join <- x %>%
  right_join(y,by = "key")
right_join

#equivalently
right_join(x, y, by = "key")
```

full join - retains all variables which correspond to all keys present in both sets

```{r}
full_join <- x %>%
   full_join(y,by="key")
full_join

#equivalently
full_join(x, y, by = "key")
```

## tibble reshape

```{r}

 #   pivot_longer() lengthens data, increasing the number of rows and decreasing the #number of columns (i.e., turning columns into rows)
    
    
 #   pivot_wider() widens data, increasing the number of columns and decreasing the #number of rows (i.e., turning rows into columns)
    
    
 #   separate() separates a character column into multiple columns with a regular #expression or numeric locations
# as in a column containing ab-01 becomes two columns ab   01 
   
    
  #   unite() unites multiple columns into one by pasting strings together
      # the reverse of the previous 

```

```{r}
iris <- as_tibble(iris)

iris

# wide to long 
iris %>%
     pivot_longer(cols = -Species, names_to = "Measurements", values_to = "Values")


# seperate 
iris %>%
     pivot_longer(cols = -Species, names_to = "Measurements", values_to = "Values") %>%
          separate(col = Measurements, into = c("Part", "Measure")) #it registered the . as the seperator

# now that you've organized the data this way you can easily produce this complex plot 
iris %>%
  pivot_longer(cols = -Species, names_to = "Measures", values_to = "Values") %>%
  separate(col = Measures, into = c("Part", "Measure")) %>%
  ggplot(aes(x = Species, y = Values, color = Part)) + 
    geom_jitter() + 
    facet_grid(cols = vars(Measure)) + 
    theme_minimal()

```

wide to long

```{r}
table <- as_tibble(table4a)
table

long <- table %>%
  pivot_longer(cols=c("1999","2000"), names_to = "Year", values_to = "cases" )

long
```

```{r}
billboard

long <- billboard %>%
  pivot_longer(cols = wk1:wk76, names_to = "Week", values_to = "Rank", values_drop_na = TRUE)
long
```

long to wide

```{r}
table2 <- as_tibble(table2)

table2

#pivot_wider(data, names_from, values_from)

  #  names_from = A string specifying the name of the column to get the name of the output column
  #  values_from = A string specifying the name of the column to get the cell values from


wide <- table2 %>%
  pivot_wider(names_from = c("type"),values_from = "count")

wide
```

separate

```{r}
table3

#by default any non alphanumeric char will be registered as the seperator

table3 %>%
  separate(rate, into = c("cases","population"))

# or explicitly sepcify the seperator
table3 %>%  separate(rate, into = c("cases", "population"), sep = "/")

#convert from char to the data type it's best suited 
table3 %>%   
  separate(rate, into = c("cases", "population"), convert = TRUE)

# or you can specify by location, posative is left to right and sep = -2 is right to left 
table3 %>%   
  separate(year, into = c("century", "year"), sep = 2)

```

unite

```{r}
table5

table5 %>%
  unite(combined_column, century, year) # wil use _ by default 


table5 %>%
  unite(combined_column, century, year, sep = "") #specify none
```

## module 13 homework

```{r}
setwd("C:/Users/jake pc/Desktop/Personal_save/Stat_405_Final_Exam")
bike <- read.csv(file="Bike_Lanes.csv",header=TRUE)
road <- read.csv(file="roads.csv",header=TRUE)
crash <- read.csv(file="crashes.csv",header=TRUE)
wide <- read.csv(file="Bike_Lanes_Wide.csv",header=TRUE)


```

Reshape wide using pivot_longer. Call this data long. Make the key lanetype, and the value\
the_length. Make sure we gather all columns but name, using -name. Note the NAs here

```{r}
wide

long <- wide %>%
    pivot_longer(cols = -name, names_to = "lanytype", values_to = "the_length",values_drop_na = TRUE)
long
```

Replace (using str_replace) any hyphens (-) with a space in crash\$Road. Call this data crash2.\
Table the Road variable.

```{r}
# reassaigns the Road variable with the output of str_replace
crash2 <- crash %>% mutate(Road = str_replace(Road, "-", " "))
table(crash2$Road)
```

Separate the Road column (using separate) into (type and number) in crash2. Reassign this to\
crash2. Table crash2\$type. Then create a new variable calling it road_hyphen using the unite\
function. Unite the type and number columns using a hyphen (-) and then table road_hyphen.

```{r}

```
